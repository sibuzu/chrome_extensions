{"version":3,"file":"lib_proxyTranscriptFetcher_js.js","mappings":"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","sources":["webpack://youtube-subtitles-extension/./lib/proxyTranscriptFetcher.js"],"sourcesContent":["/**\n * Proxy SRT Transcript Fetcher\n * Handles fetching SRT content from the proxy server when native captions are not available\n */\n\nimport { Config } from './config.js';\n\n/**\n * Fetches SRT content from the proxy server\n * @param {string} videoId - YouTube video ID\n * @param {string} language - Preferred language code (e.g., 'zh-tw')\n * @returns {Promise<Object>} - Object containing SRT content and metadata\n */\nexport async function fetchProxySRT(videoId, language = 'zh-tw') {\n  try {\n    console.log('[ProxyFetcher] Fetching SRT for video:', videoId, 'language:', language);\n    \n    // Get the SRT provider URL from user configuration\n    const srtProvider = await Config.getSrtProvider();\n    \n    if (!srtProvider) {\n      console.error('[ProxyFetcher] No SRT provider configured');\n      throw new Error('No SRT provider configured. Please configure an SRT provider in the extension settings.');\n    }\n    \n    // Remove trailing slash from srtProvider if present to prevent double slashes\n    const baseUrl = srtProvider.endsWith('/') ? srtProvider.slice(0, -1) : srtProvider;\n    \n    // Construct the URL with the correct format - always use \"default\" as the language code\n    const proxyUrl = `${baseUrl}/srt/${videoId}/default/${videoId}.srt`;\n    \n    console.log('[ProxyFetcher] Fetching SRT from proxy:', {\n      videoId,\n      language: 'default', // Always using default language code\n      proxyUrl\n    });\n    \n    // Check if we have permission to access the proxy domain\n    const hasPermission = await new Promise(resolve => {\n      chrome.permissions.contains({ origins: [`${baseUrl}/*`] }, result => {\n        console.log('[ProxyFetcher] Permission check result:', result);\n        resolve(result);\n      });\n    });\n    \n    console.log('[ProxyFetcher] Permission check result:', hasPermission);\n    \n    if (!hasPermission) {\n      console.warn('[ProxyFetcher] No permission for proxy domain, attempting fetch anyway');\n      // We'll try to fetch anyway, but it might fail due to CORS\n    }\n    \n    // Send a message to the background script to perform the fetch\n    console.log('[ProxyFetcher] Starting fetch request via background script:', proxyUrl);\n    \n    try {\n      const transcriptContent = await new Promise((resolve, reject) => {\n        const startTime = Date.now();\n        \n        console.log('[ProxyFetcher] Sending message to background script', {\n          type: 'FETCH_PROXY_SRT',\n          url: proxyUrl,\n          videoId,\n          language: 'default', // Always using default language code\n          timestamp: startTime\n        });\n        \n        chrome.runtime.sendMessage({\n          type: 'FETCH_PROXY_SRT',\n          url: proxyUrl,\n          videoId,\n          language: 'default', // Always using default language code\n          timestamp: startTime\n        }, response => {\n          const endTime = Date.now();\n          const responseTime = endTime - startTime;\n          \n          // Log the entire response for debugging\n          console.log('[ProxyFetcher] Raw response from background script:', response);\n          \n          console.log('[ProxyFetcher] Received response from background script', {\n            success: response?.success,\n            hasTranscript: !!response?.transcript,\n            hasData: !!response?.data,\n            hasError: !!response?.error,\n            responseTime: `${responseTime}ms`\n          });\n          \n          if (chrome.runtime.lastError) {\n            console.error('[ProxyFetcher] Chrome runtime error:', chrome.runtime.lastError);\n            reject(new Error(`Failed to send message to background script: ${chrome.runtime.lastError.message}`));\n            return;\n          }\n          \n          if (!response) {\n            console.error('[ProxyFetcher] No response received from background script');\n            reject(new Error('No response from background script'));\n            return;\n          }\n          \n          if (response.error) {\n            console.error('[ProxyFetcher] Background fetch failed:', response.error);\n            \n            // If this is a permission error, we need to request permission\n            if (response.error.includes('Permission denied')) {\n              reject(new Error(\n                'Permission denied for accessing the proxy server. ' +\n                'Please enable access to the proxy server in the extension settings.'\n              ));\n              return;\n            }\n            \n            reject(new Error(response.error));\n            return;\n          }\n          \n          // Extract the transcript content from the response\n          // Check for both 'transcript' and 'data' properties for backward compatibility\n          let transcriptContent = null;\n          \n          if (response.transcript) {\n            transcriptContent = response.transcript;\n            console.log('[ProxyFetcher] Found transcript property in response, length:', \n              response.transcript.length);\n          } else if (response.data) {\n            transcriptContent = response.data;\n            console.log('[ProxyFetcher] Found data property in response, length:', \n              response.data.length);\n          }\n          \n          if (!transcriptContent) {\n            console.error('[ProxyFetcher] Response missing transcript content:', response);\n            reject(new Error('Response from background script is missing transcript data'));\n            return;\n          }\n          \n          console.log('[ProxyFetcher] Successfully received SRT content from background script, length: ' +\n            transcriptContent.length);\n          \n          resolve(transcriptContent);\n        });\n      });\n      \n      return transcriptContent;\n    } catch (error) {\n      console.error('[ProxyFetcher] Background fetch failed:', error);\n      throw error;\n    }\n  } catch (error) {\n    console.error('[ProxyFetcher] Background fetch failed:', error);\n    throw error;\n  }\n}\n\n/**\n * Parses SRT content into the requested format\n * @param {string} srtContent - Raw SRT content\n * @param {string} format - Format to return ('text', 'srt', or 'json')\n * @returns {string} - Formatted transcript content\n */\nexport function parseSRTContent(srtContent, format = 'text') {\n  if (!srtContent) {\n    return '<div class=\"no-transcript\">No transcript available</div>';\n  }\n\n  // If the format is 'srt', just return the original content\n  if (format === 'srt') {\n    return srtContent;\n  }\n\n  const segments = [];\n  const srtBlocks = srtContent.trim().split(/\\r?\\n\\r?\\n/);\n\n  for (const block of srtBlocks) {\n    const lines = block.split(/\\r?\\n/);\n    if (lines.length < 3) continue;\n\n    // Parse the timestamp line (format: 00:00:00,000 --> 00:00:00,000)\n    const timestampLine = lines[1];\n    const timestampMatch = timestampLine.match(/(\\d{2}):(\\d{2}):(\\d{2}),(\\d{3}) --> (\\d{2}):(\\d{2}):(\\d{2}),(\\d{3})/);\n    \n    if (!timestampMatch) continue;\n    \n    // Convert timestamp to seconds for JSON format\n    const startHours = parseInt(timestampMatch[1], 10);\n    const startMinutes = parseInt(timestampMatch[2], 10);\n    const startSeconds = parseInt(timestampMatch[3], 10);\n    const startMilliseconds = parseInt(timestampMatch[4], 10);\n    \n    const endHours = parseInt(timestampMatch[5], 10);\n    const endMinutes = parseInt(timestampMatch[6], 10);\n    const endSeconds = parseInt(timestampMatch[7], 10);\n    const endMilliseconds = parseInt(timestampMatch[8], 10);\n    \n    const startTime = startHours * 3600 + startMinutes * 60 + startSeconds + startMilliseconds / 1000;\n    const endTime = endHours * 3600 + endMinutes * 60 + endSeconds + endMilliseconds / 1000;\n    \n    // Get the text content (could be multiple lines)\n    const text = lines.slice(2).join(' ');\n    \n    if (format === 'json') {\n      segments.push({\n        start: parseFloat(startTime.toFixed(2)),\n        duration: parseFloat((endTime - startTime).toFixed(2)),\n        text: text\n      });\n    } else {\n      // For text format, just push the text\n      segments.push(text);\n    }\n  }\n\n  // Handle different formats\n  if (format === 'json') {\n    // Return JSON string for JSON format\n    return JSON.stringify(segments, null, 2);\n  } else {\n    // For text format, join all text segments with a space for compactness\n    if (segments.length === 0) {\n      return '<div class=\"no-transcript\">No transcript segments found</div>';\n    }\n    \n    // Join all text segments with a space (not line breaks) to make it compact\n    // This matches how native CC handles text formatting\n    return segments.join(' ').trim();\n  }\n}\n"],"names":["Config","fetchProxySRT","videoId","language","console","log","srtProvider","getSrtProvider","error","Error","baseUrl","endsWith","slice","proxyUrl","hasPermission","Promise","resolve","chrome","permissions","contains","origins","result","warn","transcriptContent","reject","startTime","Date","now","type","url","timestamp","runtime","sendMessage","response","endTime","responseTime","success","hasTranscript","transcript","hasData","data","hasError","lastError","message","includes","length","parseSRTContent","srtContent","format","segments","srtBlocks","trim","split","block","lines","timestampLine","timestampMatch","match","startHours","parseInt","startMinutes","startSeconds","startMilliseconds","endHours","endMinutes","endSeconds","endMilliseconds","text","join","push","start","parseFloat","toFixed","duration","JSON","stringify"],"sourceRoot":""}